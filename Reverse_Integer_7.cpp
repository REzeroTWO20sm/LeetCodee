#include <iostream>
#include <string>
#include <limits> 

int reverseInteger(int x) {
    int result = 0;

    while (x != 0) {
        int digit = x % 10;
        x /= 10;

        if (result > std::numeric_limits<int>::max() / 10 || (result == std::numeric_limits<int>::max() / 10 && digit > 7))
            return 0;
        if (result < std::numeric_limits<int>::min() / 10 || (result == std::numeric_limits<int>::min() / 10 && digit < -8))
            return 0;

        result = result * 10 + digit;
    }

    return result;
}

int main() {
    int x = -123;
    
    int reversed = reverseInteger(x);

    std::cout << reversed;

    return 0;
}













// 1. Результат > std::numeric_limits<int>::max() / 10:
//    - Это условие проверяет, превышает ли текущее обратное значение целого числа (результат) максимальное значение, которое может содержать тип int (std::numeric_limits<int>::max()), поделенное на 10.
//    - Цель этой проверки - предотвратить переполнение при умножении результата на 10 и добавлении следующей цифры к нему. Если результат уже больше или равен (INT_MAX / 10), то умножение его на 10 приведет к переполнению.
//    - Если условие истинно, это означает, что произошло бы переполнение, и функция возвращает 0 для указания ошибки.

// 2. (result == std::numeric_limits<int>::max() / 10 && digit > 7):
//    - Это условие проверяет специальный случай переполнения, когда текущее обратное значение целого числа (результат) равно (INT_MAX / 10), а следующая цифра (digit) больше 7.
//    - В этом случае умножение результата на 10 и добавление цифры приведет к значению, большему, чем INT_MAX, и возникнет переполнение.
//    - Если условие истинно, это означает, что произошло бы переполнение, и функция возвращает 0 для указания ошибки.

// 3. result < std::numeric_limits<int>::min() / 10:
//    - Это условие проверяет, меньше ли текущее обратное значение целого числа (результат) минимального значения, которое может содержать тип int (std::numeric_limits<int>::min()), поделенное на 10.
//    - Цель этой проверки - предотвратить недостаточное значение при умножении результата на 10 и добавлении следующей цифры к нему. Если результат уже меньше или равен (INT_MIN / 10), то умножение его на 10 приведет к недостаточному значению.
//    - Если условие истинно, это означает, что произошло бы недостаточное значение, и функция возвращает 0 для указания ошибки.

// 4. (result == std::numeric_limits<int>::min() / 10 && digit < -8):
//    - Это условие проверяет специальный случай недостаточного значения, когда текущее обратное значение целого числа (результат) равно (INT_MIN / 10), а следующая цифра (digit) меньше -8.
//    - В этом случае умножение результата на 10 и добавление цифры приведет к значению, меньшему, чем INT_MIN, и возникнет недостаточное значение.
//    - Если условие истинно, это означает, что произошло бы недостаточное значение, и функция возвращает 0 для указания ошибки.

// Эти условия добавлены в качестве защиты, чтобы функция reverseInteger правильно обрабатывала потенциальные ситуации переполнения и недостаточного значения, предотвращая потерю данных или непредвиденное поведение при обращении целых чисел.











// #include <iostream>
// #include <string>
// #include <cmath>
// //g++ Reverse_Integer_7.cpp -o Reverse_Integer_7 --std=c++14 -I/usr/local/include

// int main(){
//     int x = 901000;
//     int result = 0;

//     for(int i = 10; x % 10 == 0; i = 10){
//         x /= 10;
//     }
    
//     std::cout << x << "   ";

//     int nums_count = std::to_string(abs(x)).length();

//     std::cout<< nums_count << "   ";

//     for(int i = 10; nums_count > 0; i = 10){
//         int buffer = x % 10;
//         result += ((x % buffer) * std::pow(10.0, static_cast<double>(nums_count)));
//         nums_count -= 1;
//         std::cout << x % buffer << " ";
//         x = x / 10;
//     }
//     std::cout << result;
// }